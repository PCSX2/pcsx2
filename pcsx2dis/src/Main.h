typedef unsigned int addr;
/*typedef unsigned __int32 UINT32;
typedef unsigned __int16 UINT16;
typedef unsigned __int8  UINT8;
typedef __int32 INT32;
typedef __int16 INT16;
typedef __int8  INT8;*/
#ifndef _BASETSD_H_
#include <BaseTsd.h>
#endif

//#undef _DLL

#define VERSIONSTRING "1.1"
#define DEFAULTWINDOWTITLE "PCSX2dis " VERSIONSTRING

#define DATATYPE_BYTE  1
#define	DATATYPE_HWORD 2
#define	DATATYPE_WORD  3
#define	DATATYPE_DWORD 4
#define	DATATYPE_QWORD 5
#define	DATATYPE_CODE  6
#define DATATYPE_FLOAT 7

#define VARNAMEMAX 32

#define MST_SETVALUE 1

#pragma pack(push,1)
struct Label
{
	char string[512];
	addr address;
	bool autoGenerated;
};

struct Comment
{
	char string[512];
	addr address;
	bool autoGenerated;
};

struct RegSetter
{
	UINT8 reg;
	UINT32 value;
};

struct RegNamer
{
	UINT8 reg;

	char name[17];
};

struct RegOverride
{
	addr address;

	RegSetter* regSetters;
	RegNamer* regNamers;

	INT8 numRegSetters;
	INT8 numRegNamers;
};

struct StructVar
{
	char name[VARNAMEMAX];
	INT32 offset;
	char dataType;

	INT32 numItems; // Number of data items in an array. If it's not an array this value will be 1. This value should never be zero.
};

struct StructDef
{
	char name[50];
	INT32 size;
	char* script; // The user-written script that defines this StructDef

	StructVar* vars;
	INT32 numVars;
};

struct StructInst
{
	UINT32 address;
	INT32 structDefId;
	INT32 numInsts;
};

struct line_t
{
	INT8 datatype : 4;
//	INT8 labelGenerated : 1; // If true, this means the data type was automatically set by an auto-generated label and can be reset if the label is removed
	INT8 unused : 4;
	UINT8 referenced;
	UINT32 reference;
};
#pragma pack(pop)

extern unsigned int* mem;
extern short*        mem16;
extern char*         mem8;
extern int           memlen32;
extern int			 memlen16;
extern int			 memlen8;

extern line_t* lines;

extern Label* labels;
extern int numlabels;

extern Comment* comments;
extern int   numcomments;

extern RegOverride* regOverrides;
extern int numRegOverrides;

extern StructDef* structDefs;
extern int numStructDefs;

extern StructInst* structInsts;
extern int numStructInsts;

extern const int datasizes[8];

void MainStartup();
bool MainUpdate();
void MainCleanup();

void AddLabel(UINT32 address, const char* label, bool autoGenerated);
void RemoveLabel(UINT32 address);

void SetComment(UINT32 address, const char* comment, bool autoGenerated);
void ClearAutoGeneratedComments();

RegOverride* AddRegOverride(addr address);
void AddRegSetter(RegOverride* destOverride, int regId, UINT32 regValue);
void AddRegNamer(RegOverride* destOverride, int regId, const char* regName);

void RemoveStructDef(int id);

void AddStructInst(addr address, int structId, int number);
void RemoveStructInst(int id);

void UserSaveProject();
void UserSaveProjectAs();
void UserOpenProject();
void UserNewProject();

void* Alloc(int numBytes);
void* Realloc(void* ptr, int numBytes);
void* Free(void* ptr);

void String_Replace(char* main_string, char* culprit_string, char* officer_string);

inline void SetReference(UINT32 destAddr, UINT32 sourceAddr)
{
	// TODO: Manage reference-changing better so that now-unreferenced addresses lose their 'referenced' flag
	if (destAddr >= memlen8 || sourceAddr >= memlen8) return;

	lines[sourceAddr / 4].reference = destAddr;
	lines[destAddr / 4].referenced |= 1 << (destAddr & 3);
}