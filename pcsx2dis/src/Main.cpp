#include <cstdio>
#include <iostream>
#include <windows.h>

#include "Main.h"
#include "Windows.h"
#include "Logical.h"
#include "Processor.h"
#include "Analyse.h"
#include "MainList.h"
#include "GameShark.h"
#include "Dialogs.h"

unsigned int* mem;
short*        mem16;
char*         mem8;
int			  memlen8;
int			  memlen16;
int           memlen32;

line_t* lines;

Label* labels;
int numlabels;

Comment* comments;
int   numcomments;

RegOverride* regOverrides;
int numRegOverrides;

StructDef* structDefs;
int numStructDefs;

StructInst* structInsts;
int numStructInsts;

const int datasizes[8] = {0, 1, 2, 4, 8, 16, 4, 4};

void Converter_Setup();
void Convert(unsigned int start, unsigned int end);

void AddrHistAdd();

// MainStartup should be called only on program init!
void MainStartup()
{
	ClearItems();

	printf("Setting up converter...\n");
	Converter_Setup();

	AddrHistAdd(); // Entrypoint! Well kind of...
}

bool MainUpdate()
{
	static int lastupdate = 0;
	bool quit = false;
	MSG message;

	while (PeekMessage(&message, NULL, 0, 0, PM_REMOVE) > 0)
	{
#ifndef _DLL
		if (message.message == WM_QUIT)
			quit = true;
#endif
		// HACK! We're sending a copy of the keystroke receipt to main_hwnd as well. In fact we might not even let it through to listbox_hwnd.
		if ((message.hwnd == listbox_hwnd && (message.message == WM_KEYDOWN)) || 
			(message.hwnd == wndEdit.hwnd && (message.message == WM_KEYDOWN)))
		{
			MSG message_copy;
			bool relay_message; // Sometimes we might not want to pass on the message...

			memcpy(&message_copy, &message, sizeof (MSG));

			message_copy.hwnd = main_hwnd;

							TranslateMessage (&message_copy);
			relay_message = DispatchMessage  (&message_copy);

			if (! relay_message)
				continue;
		}

		if (! IsDialogMessage(dlgProgress.hwnd, &message))
		{
			TranslateMessage (&message);
			DispatchMessage  (&message);
		}
	}
	
	UpdateListScroll();

	if (GetTickCount() - lastupdate >= 500)
	{
		// Update list (half-second update)
		int sel = SendMessage(listbox_hwnd, LB_GETCURSEL, 0, 0);

		UpdateList();
		UpdateTextbox();

		SendMessage(listbox_hwnd, LB_SETCURSEL, sel, 0);
		lastupdate = GetTickCount();
	}

#ifdef _DLL
	HandleBreakpoints();
#endif

	return !quit;
}

void MainCleanup()
{
	// NOTE: Converter stuff is never cleaned up
	for (int i = 0; i < numRegOverrides; i ++)
	{
		Free(regOverrides[i].regSetters);
		Free(regOverrides[i].regNamers);
	}

	for (int i = 0; i < numStructDefs; i ++)
	{
		Free(structDefs[i].script);
		Free(structDefs[i].vars);
	}

	Free(regOverrides);
	Free(structInsts);
	Free(structDefs);
	Free(comments);
	Free(labels);
	Free(list.addrhist);

	Free(gameSharkCodeString);
	Free(gameSharkCodes);

	regOverrides = NULL;
	structDefs = NULL;
	structInsts = NULL;
	comments = NULL;
	labels = NULL;
	list.addrhist = NULL;
	gameSharkCodeString = NULL;
	gameSharkCodes = NULL;

	numlabels = 0;
	numcomments = 0;
	numRegOverrides = 0;
	numGameSharkCodes = 0;
	numStructInsts = 0;
	numStructDefs = 0;

	list.addrhistmax = 0;
	list.addrhistpos = 0;
	list.numitems = 0;

	for (int i = 0; i < memlen32; i ++)
	{
		lines[i].datatype = DATATYPE_CODE;
		lines[i].reference = 0xFFFFFFFF;
		lines[i].referenced = 0;
	}

	for (int i = 0; i < 10; i ++)
		breakpoints[i].enabled = false;

#ifdef _DLL
	for (int i = 0; i < BREAKPOINT_MAX; i ++)
		lxSharedData->internalBreakpoints[i] = 0x00000000;
#endif

	GameSharkResetScanner();
	ClearBreakpoints();

	UpdateStructManagerWindow();

	UpdateList();
	AddrHistAdd();
}

void String_Replace(char* main_string, char* culprit_string, char* officer_string)
{
	int main_length    = String_Length (main_string);
	int culprit_length = String_Length (culprit_string) - 1;
	int officer_length = String_Length (officer_string) - 1;

	for (int i = 0; i < main_length - culprit_length; i ++)
	{
		if (String_Compare_Part(&main_string[i], culprit_string, culprit_length))
		{
			int offset = officer_length - culprit_length;

			for (int l = main_length + offset; l > i + culprit_length; l --)
				main_string[l] = main_string[l - offset];

			for (int l = 0; l < officer_length; l ++)
				main_string[i + l] = officer_string[l];

			main_length += offset;
			i += offset;
		}
	}
}

void AddLabel(UINT32 address, const char* label, bool autoGenerated)
{
	int numextrachars = 0;
	int i;

	for (i = 0; label[i] != '\0'; i ++) {if (label[i] == 0x0A) numextrachars ++;}

	// WARNING: Changing the Label struct without compiling this file could have some disastrous results!
	int labelLen = i;

	if (numlabels / 256 * 256 == numlabels)
		labels = (Label*) Realloc(labels, (numlabels + 256) * sizeof (Label)); // Reallocate in lots of 256
	
	labels[numlabels].address = address;
	labels[numlabels].autoGenerated = autoGenerated;

	if (labelLen + numextrachars < 512)
	{
		strncpy(labels[numlabels].string, label, 512-1);
		labels[numlabels].string[labelLen] = '\0';
	}
	else
	{
		strncpy(labels[numlabels].string, label, 512-1 - numextrachars);
		labels[numlabels].string[labelLen - numextrachars] = '\0';
	}

	String_Replace(labels[numlabels].string, "\x0A", "\\n");

	numlabels ++;
}

void RemoveLabel(UINT32 address)
{
	int labelId;

	for (labelId = 0; labelId < numlabels; labelId ++)
	{
		if (labels[labelId].address == address)
			break;
	}

	if (labelId == numlabels)
		return;

	numlabels --;

	for (int i = labelId; i < numlabels; i ++)
		labels[i] = labels[i + 1];

	// Note: This function doesn't actually free memory, fix later? (RemoveLabel shouldn't be used frequently anyway)
}

void SetComment(UINT32 address, const char* comment, bool autoGenerated)
{
	int id = 0;

	for (id = 0; id < numcomments; id ++)
	{
		if (comments[id].address == address)
			break;
	}

	if (id == numcomments)
	{
		comments = (Comment*) Realloc(comments, (id + 1) * sizeof (Comment));

		numcomments ++;
	}
	else if (! comments[id].autoGenerated && autoGenerated) // Don't overwrite this comment
		return;

	comments[id].address = address;
	strncpy(comments[id].string, comment, 512-1);
	comments[id].string[512-2] = '\0';
	comments[id].autoGenerated = autoGenerated;
}

void ClearAutoGeneratedComments()
{
	int numAutos = 0;

	for (int i = 0; i < numcomments; i ++)
	{
		if (comments[i].autoGenerated)
			numAutos ++;
	}

	Comment* newComments = (Comment*) Alloc((numcomments - numAutos) * sizeof (Comment));
	int numNewComments = 0;

	for (int i = 0; i < numcomments; i ++)
	{
		if (comments[i].autoGenerated)
			continue;

		newComments[numNewComments ++] = comments[i];
	}

	Free(comments);

	comments = newComments;
	numcomments = numNewComments;
}

RegOverride* AddRegOverride(addr address)
{
	regOverrides = (RegOverride*) Realloc(regOverrides, (numRegOverrides + 1) * sizeof (RegOverride));

	RegOverride* newOverride = &regOverrides[numRegOverrides ++];

	memset(newOverride, 0, sizeof (RegOverride));

	newOverride->address = address;
	return newOverride;
}

void AddRegSetter(RegOverride* destOverride, int regId, UINT32 regValue)
{
	destOverride->regSetters = (RegSetter*) Realloc(destOverride->regSetters, (destOverride->numRegSetters + 1) * sizeof (RegSetter));
	
	destOverride->regSetters[destOverride->numRegSetters].reg = regId;
	destOverride->regSetters[destOverride->numRegSetters].value = regValue;

	destOverride->numRegSetters ++;
}

void AddRegNamer(RegOverride* destOverride, int regId, const char* regName)
{
	destOverride->regNamers = (RegNamer*) Realloc(destOverride->regNamers, (destOverride->numRegNamers + 1) * sizeof (RegNamer));
	
	destOverride->regNamers[destOverride->numRegNamers].reg = regId;
	strncpy(destOverride->regNamers[destOverride->numRegNamers].name, regName, 16);

	destOverride->regNamers[destOverride->numRegNamers].name[16] = '\0';

	destOverride->numRegNamers ++;
}

void AddStructInst(addr address, int structDefId, int number)
{
	if (! number)
		return;

	// Remove any struct insts already existing on this line
	for (int i = 0; i < numStructInsts; i ++)
	{
		if (structInsts[i].address == address)
			RemoveStructInst(i--);
	}

	// Add the struct inst
	structInsts = (StructInst*) Realloc(structInsts, sizeof (StructInst) * (numStructInsts + 1));

	structInsts[numStructInsts].address = address;
	structInsts[numStructInsts].structDefId = structDefId;
	structInsts[numStructInsts].numInsts = number;

	numStructInsts ++;

	// Update the data types in the list as defined in the structdef
	addr curAddress = address;
	StructDef* def = &structDefs[structDefId];
	for (int i = 0; i < number; i ++)
	{
		for (int j = 0; j < def->numVars; j ++)
			lines[(curAddress + def->vars[j].offset) / 4].datatype = def->vars[j].dataType;

		curAddress += def->size;
	}
}

void RemoveStructInst(int instId)
{
	if (instId >= numStructInsts)
		return;

	numStructInsts --;
	for (int i = instId; i < numStructInsts; i ++)
		structInsts[i] = structInsts[i + 1];
}

void RemoveStructDef(int structDefId)
{
	if (structDefId >= numStructDefs)
		return;

	Free(structDefs[structDefId].script);
	Free(structDefs[structDefId].vars);

	// Remove this struct def
	numStructDefs --;
	for (int i = structDefId; i < numStructDefs; i ++)
		structDefs[i] = structDefs[i + 1];

	// Remove every reference to this struct def on the main list
	for (int i = 0; i < numStructInsts; i ++)
	{
		if (structInsts[i].structDefId == structDefId)
			RemoveStructInst(i --);
		else if (structInsts[i].structDefId > structDefId)
			structInsts[i].structDefId --;
	}
}

void SaveMemoryDump()
{
	OPENFILENAME ofn;
	char filename[256] = "Dump.bin";

	memset(&ofn, 0, sizeof (ofn));

	ofn.lStructSize = sizeof (ofn);
	ofn.hwndOwner = main_hwnd;
	ofn.hInstance = globalInst;
	ofn.lpstrFilter = "Binary files (*.bin)\0*.bin\0\0";
	ofn.lpstrFile = filename;
	ofn.nMaxFile = 256;
	ofn.nFilterIndex = 1;
	ofn.lpstrTitle = "Save Memdump";
	ofn.Flags = OFN_PATHMUSTEXIST;
	//ofn.lpstrDefExt = "bin";

	GetSaveFileName(&ofn);

	if (strlen(ofn.lpstrFile))
	{
		FILE* f = fopen(ofn.lpstrFile, "wb");

		fwrite(mem, memlen8, 1, f);
		fclose(f);
	}
}

char projectName[MAX_PATH];

void SaveProject(const char* filename);
void OpenProject(const char* filename);

void UserNewProject()
{
	if (strlen(projectName))
	{
		if (MessageBox(main_hwnd, "You currently have a project open. Are you sure you wish to start a new project? Any of your shiny unsaved data will be lost!", 
			"It's normally obvious but y'know just in case", MB_ICONWARNING | MB_YESNO) != IDYES)
			return;
	}

	projectName[0] = '\0';
	
	MainCleanup();

	SendMessage(main_hwnd, WM_SETTEXT, 0, (LPARAM) DEFAULTWINDOWTITLE);
}

void UserOpenProject()
{
	OPENFILENAME ofn;
	char filename[256] = "";

	memset(&ofn, 0, sizeof (ofn));

	ofn.lStructSize = sizeof (ofn);
	ofn.hwndOwner = main_hwnd;
	ofn.hInstance = globalInst;
	ofn.lpstrFilter = "IDon'tEven files (*.ide)\0*.ide\0\0";
	ofn.lpstrFile = filename;
	ofn.nMaxFile = 256;
	ofn.nFilterIndex = 1;
	ofn.lpstrTitle = "Open Project File";
	ofn.Flags = OFN_PATHMUSTEXIST;

	GetOpenFileName(&ofn);

	if (strlen(ofn.lpstrFile))
	{
		char wndTitle[MAX_PATH + 20];

		OpenProject(ofn.lpstrFile);

		strcpy(projectName, ofn.lpstrFile);
		sprintf(wndTitle, DEFAULTWINDOWTITLE " [%s]", projectName);
		SendMessage(main_hwnd, WM_SETTEXT, 0, (LPARAM) wndTitle);
	}
}

void UserSaveProjectAs()
{
	OPENFILENAME ofn;
	char filename[256] = "Project.ide";

	memset(&ofn, 0, sizeof (ofn));

	ofn.lStructSize = sizeof (ofn);
	ofn.hwndOwner = main_hwnd;
	ofn.hInstance = globalInst;
	ofn.lpstrFilter = "IDon'tEven files (*.ide)\0*.ide\0\0";
	ofn.lpstrFile = filename;
	ofn.nMaxFile = 256;
	ofn.nFilterIndex = 1;
	ofn.lpstrTitle = "Save Project File";
	ofn.Flags = OFN_PATHMUSTEXIST;
	ofn.lpstrDefExt = "bin";

	GetSaveFileName(&ofn);

	if (strlen(ofn.lpstrFile))
	{
		char wndTitle[MAX_PATH + 20];

		SaveProject(ofn.lpstrFile);
		
		strcpy(projectName, ofn.lpstrFile);
		sprintf(wndTitle, DEFAULTWINDOWTITLE " [%s]", projectName);
		SendMessage(main_hwnd, WM_SETTEXT, 0, (LPARAM) wndTitle);
	}
}

void UserSaveProject()
{
	if (! strlen(projectName))
	{
		UserSaveProjectAs();
		return;
	}

	SaveProject(projectName);
}

void* Alloc(int numBytes)
{
	return VirtualAlloc((void*) NULL, numBytes, MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);
}

void* Realloc(void* ptr, int numBytes)
{
	if (ptr)
	{
		MEMORY_BASIC_INFORMATION mbi;
		void* newMem = VirtualAlloc((void*) NULL, numBytes, MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);

		VirtualQuery(ptr, &mbi, sizeof (mbi));
		memcpy(newMem, ptr, numBytes >= mbi.RegionSize ? mbi.RegionSize : numBytes);

		VirtualFree(ptr, 0, MEM_RELEASE);
		return newMem;
	}
	else
		return VirtualAlloc((void*) NULL, numBytes, MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE);
}

void* Free(void* ptr)
{
	VirtualFree(ptr, 0, MEM_RELEASE);
	return NULL;
}