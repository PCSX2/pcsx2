diff --git a/.cmake.conf b/.cmake.conf
--- a/.cmake.conf
+++ b/.cmake.conf
@@ -51,7 +51,7 @@ set(QT_MAX_NEW_POLICY_CMAKE_VERSION_QT_APPLE "3.21")
 set(QT_SUPPORTED_MIN_MACOS_SDK_VERSION "14")
 set(QT_SUPPORTED_MAX_MACOS_SDK_VERSION "26")
 set(QT_SUPPORTED_MIN_MACOS_XCODE_VERSION "15")
-set(QT_SUPPORTED_MIN_MACOS_VERSION "13")
+set(QT_SUPPORTED_MIN_MACOS_VERSION "11")
 set(QT_SUPPORTED_MAX_MACOS_VERSION_TESTED "26")
 
 set(QT_SUPPORTED_MIN_IOS_SDK_VERSION "17")
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -12,6 +12,10 @@ cmake_minimum_required(VERSION 3.16)
 # Get the repo version and CMake policy details
 include(.cmake.conf)
 
+if(APPLE)
+  add_compile_options(-Werror=unguarded-availability-new)
+endif()
+
 include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/QtBaseHelpers.cmake)
 
 qt_internal_check_if_path_has_symlinks("${CMAKE_BINARY_DIR}")
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -1027,7 +1027,7 @@ QByteArray QSysInfo::machineUniqueId()
 {
 #if defined(Q_OS_DARWIN) && __has_include(<IOKit/IOKitLib.h>)
     char uuid[UuidStringLen + 1];
-    io_service_t service = IOServiceGetMatchingService(kIOMainPortDefault, IOServiceMatching("IOPlatformExpertDevice"));
+    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOPlatformExpertDevice"));
     QCFString stringRef = (CFStringRef)IORegistryEntryCreateCFProperty(service, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0);
     CFStringGetCString(stringRef, uuid, sizeof(uuid), kCFStringEncodingMacRoman);
     return QByteArray(uuid);
diff --git a/src/corelib/kernel/qcore_mac.mm b/src/corelib/kernel/qcore_mac.mm
--- a/src/corelib/kernel/qcore_mac.mm
+++ b/src/corelib/kernel/qcore_mac.mm
@@ -367,7 +367,7 @@ bool qt_apple_runningWithLiquidGlass()
             return config;
 #endif
 
-        QIOType<io_registry_entry_t> nvram = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/options");
+        QIOType<io_registry_entry_t> nvram = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/options");
         if (!nvram) {
             qWarning("Failed to locate NVRAM entry in IO registry");
             return {};
diff --git a/src/gui/platform/darwin/qappleiconengine.mm b/src/gui/platform/darwin/qappleiconengine.mm
--- a/src/gui/platform/darwin/qappleiconengine.mm
+++ b/src/gui/platform/darwin/qappleiconengine.mm
@@ -366,12 +366,16 @@
                                                weight:NSFontWeightRegular
                                                scale:NSImageSymbolScaleLarge];
 
+    auto *primaryColor = [NSColor colorWithSRGBRed:color.redF()
+                                             green:color.greenF()
+                                              blue:color.blueF()
+                                             alpha:color.alphaF()];
+
+    if (@available(macOS 13, *)) {
+
     // Apply tint color first, which switches the configuration to palette mode
     config = [config configurationByApplyingConfiguration:
-        [NSImageSymbolConfiguration configurationWithPaletteColors:@[
-            [NSColor colorWithSRGBRed:color.redF() green:color.greenF()
-                blue:color.blueF() alpha:color.alphaF()]
-        ]]];
+        [NSImageSymbolConfiguration configurationWithPaletteColors:@[primaryColor]]];
 
     // Then switch back to monochrome, as palette mode gives a different look
     // than monochrome, even with a single color.
@@ -379,6 +383,18 @@
         [NSImageSymbolConfiguration configurationPreferringMonochrome]];
 
     return [image imageWithSymbolConfiguration:config];
+
+    } else {
+    NSImage *configuredImage = [image imageWithSymbolConfiguration:config];
+    return [NSImage imageWithSize:configuredImage.size flipped:NO
+        drawingHandler:^BOOL(NSRect) {
+            [primaryColor set];
+            NSRect imageRect = {NSZeroPoint, configuredImage.size};
+            [configuredImage drawInRect:imageRect];
+            NSRectFillUsingOperation(imageRect, NSCompositingOperationSourceIn);
+            return YES;
+        }];
+    }
 }
 #elif defined(QT_PLATFORM_UIKIT)
 auto *configuredImage(const UIImage *image, const QColor &color)
diff --git a/src/plugins/platforms/cocoa/qcocoawindow.mm b/src/plugins/platforms/cocoa/qcocoawindow.mm
--- a/src/plugins/platforms/cocoa/qcocoawindow.mm
+++ b/src/plugins/platforms/cocoa/qcocoawindow.mm
@@ -323,6 +323,8 @@ a normal (not maximized or full screen) top-level window.
         m_view.safeAreaInsets.bottom
     };
 
+    if (@available(macOS 12, *)) {
+
     // The screen's safe area insets represent the distances from the screen's
     // edges at which content isn't obscured. The view's safe area margins do
     // not include the screen's insets automatically, so we need to manually
@@ -355,6 +357,10 @@ a normal (not maximized or full screen) top-level window.
     };
 
     return (screenSafeAreaMargins | viewSafeAreaMargins).toMargins();
+
+    } else {
+        return viewSafeAreaMargins.toMargins();
+    }
 }
 
 void QCocoaWindow::updateSafeAreaMarginsIfNeeded()
